---
title: "LLD: Design a Vending Machine"
summary: "A practical guide to designing a vending machine system, covering object-oriented principles, state management, and extensibility. Learn how to model real-world interactions and handle concurrency in software design."
publishedAt: "2025-09-27"
tag: [Low Level Design", "OOPs", "Design Patterns"]
---

The goal of designing a vending machine is to create a robust system that manages product inventory, handles payments and change, supports concurrent transactions, and provides interfaces for restocking and maintenance, ensuring reliability and user convenience.

## Requirements

- The vending machine should support multiple products with different prices and quantities.
- The machine should accept coins and notes of different denominations.
- The machine should dispense the selected product and return change if necessary.
- The machine should keep track of the available products and their quantities.
- The machine should handle multiple transactions concurrently and ensure data consistency.
- The machine should provide an interface for restocking products and collecting money.
- The machine should handle exceptional scenarios, such as insufficient funds or out-of-stock products.

<hr />


## Simulation Class

```java
package Simulation;

import vendingMachine.MyVendingMachine;

import java.util.Scanner;

public class VendingMachineMain {
    public static void main(String[] args){
        MyVendingMachine vendingMachine= new MyVendingMachine();
        vendingMachine.showOptions();

        vendingMachine.selectProduct("coke");


        Scanner scanner = new Scanner(System.in);
        System.out.println("Select Payment mode: (note/coin)");
        String paymentMode = scanner.nextLine();

        System.out.println("Enter amount: ");
        double paymentAmount = Double.parseDouble(scanner.nextLine());

        vendingMachine.insertMoney(paymentMode, paymentAmount);


        vendingMachine.selectProduct("coke");


        System.out.println("Select Payment mode: (note/coin)");
        String paymentMode2 = scanner.nextLine();

        System.out.println("Enter amount: ");
        double paymentAmount2 = Double.parseDouble(scanner.nextLine());

        vendingMachine.insertMoney(paymentMode2, paymentAmount2);

    }
}

```

## Actors & Responsibilities

### 1. `MyVendingMachine` (Facade)

* Entry point for the client.
* Provides simple methods:

  * `selectProduct()`
  * `insertMoney()`
  * `dispenseProduct()`
  * `showOptions()`
* Internally delegates requests to the **VendingMachineController**.

    ```java
    import lombok.Setter;

    import java.util.*;

    // facade
    public class MyVendingMachine {

        VendingMachineController controller;

        public MyVendingMachine(){
            controller = new VendingMachineController();
        }

        public void insertMoney(String paymentMode, double amount){
            switch(paymentMode){
                case "coin" -> controller.handlePayment(Denomination.COIN, amount);
                case "note" -> controller.handlePayment(Denomination.NOTE, amount);
                default -> throw new IllegalArgumentException("Invalid payment mode");
            }
        }

        public void selectProduct(String productName){
            System.out.println("Selected Product: "+productName);
            controller.selectProduct(productName);
        }

        public void dispenseProduct(){
            System.out.println("Dispensing Product...");
            controller.dispenseProduct();
        }

        public void showOptions(){
            controller.showOptions();
        }
    }
    ```

### 2. `VendingMachineController` (Core Orchestrator)

* Coordinates between **inventory**, **payment service**, and **state machine**.
* Maintains the current state (`Idle`, `WaitingForMoney`, etc.) and current product selection.
* Routes calls:

  * `selectProduct()` → handled by current state
  * `handlePayment()` → forwards to current state
  * `dispenseProduct()` → handled by current state
* Responsible for giving change (`collectMoney()`).

    ```java

    class VendingMachineController {
        VendingInventory inventory;
        private ThreadLocal<MachineState> machineState = ThreadLocal.withInitial(() -> new IdleState(this));
        private ThreadLocal<Product> currentSelection;
        private ThreadLocal<VendingPaymentService> paymentService =
                ThreadLocal.withInitial(VendingPaymentService::new);

        VendingMachineController(){
            inventory = VendingInventory.getInstance();
        }

        public void setState(MachineState state){
            machineState.set(state);
        }

        public MachineState getState(){
            return machineState.get();
        }

        public VendingPaymentService getPaymentService() {
            return paymentService.get();
        }

        // one product can be selected at a time
        void selectProduct(String productName){
            getState().selectProduct(productName);

        }

        void handlePayment(Denomination type, double amount){
            getState().insertMoney(type, amount);
        }

        void dispenseProduct(){
            getState().dispenseProduct();

        }

        void setCurrentSelected(Product selected){
            currentSelection.set(selected);
        }

        Product getCurrentSelected(){
            return currentSelection.get();
        }

        void showOptions()
        {
            Map<String, Double> products = inventory.getAllProducts();
            System.out.println("Available Products: ");
            int idx=1;
            for(Map.Entry<String, Double> entry: products.entrySet()){
                System.out.println(idx++ + ". " + entry.getKey() + " - Price: " + entry.getValue());
            }
        }


        void collectMoney(){
            double change = getPaymentService().returnChange(getCurrentSelected().getProductPrice());
            System.out.println("User can collect the money: "+ change);
        }
    }
    ```
### 3. `MachineState` & Implementations (State Pattern)

Represents different machine conditions:

* **IdleState** → waiting for user to pick a product.
* **WaitingForMoneyState** → product selected, waiting for payment.
* **DispensingProductState** → dispensing product + returning change.
* **OutOfStockState** → selected product not available.
* **InsufficientFundsState** → user inserted less money, needs to add more.

Each state defines allowed operations and restricts invalid actions.

    ```java

    interface MachineState {
        void insertMoney(Denomination type, double amount);
        void selectProduct(String productName);
        void dispenseProduct();
    }

    class IdleState implements MachineState {
        private VendingMachineController controller;

        IdleState(VendingMachineController controller) {
            this.controller = controller;
        }

        @Override
        public void selectProduct(String productName){
            Product product = controller.inventory.getProduct(productName);
            if (product == null || product.getQuantity() <= 0) {
                System.out.println("Product not available.");
                controller.setState(new OutOfStockState(controller));
                return;
            }
            controller.setCurrentSelected(product);
            System.out.println("Product " + product.getProductName() + " selected. Price: " + product.getProductPrice());
            controller.setState(new WaitingForMoneyState(controller));

        }

        @Override
        public void insertMoney(Denomination type, double amount){
            System.out.println("Please select a product first.");
        }

        @Override
        public void dispenseProduct() {
            System.out.println("No product selected yet.");
        }
    }

    class WaitingForMoneyState implements MachineState{
        private VendingMachineController controller;

        WaitingForMoneyState(VendingMachineController c){
            this.controller = c;
        }

        @Override
        public void insertMoney(Denomination type, double amount){
            System.out.println("In waiting for Money State");
            switch(type) {
                case COIN -> controller.getPaymentService().setStrategy(new CoinPaymentStrategy());
                case NOTE -> controller.getPaymentService().setStrategy(new NotePaymentStrategy());
            }

            boolean success = controller.getPaymentService().processPayment(amount, controller.getCurrentSelected().getProductPrice());
            if(success){
                controller.setState(new DispensingProductState(controller));
                controller.dispenseProduct();
            } else {
                controller.setState(new InsufficientFundsState(controller));
                System.out.println("payment failed");
            }
        }
        @Override
        public void selectProduct(String productName){
            System.out.println("Product already selected. Please insert money.");
        }
        @Override
        public void dispenseProduct()
        {
            System.out.println("Cannot dispense. Waiting for money.");
        }
    }

    class DispensingProductState implements MachineState{
        private VendingMachineController controller;


        DispensingProductState(VendingMachineController c){
            this.controller = c;
        }

        @Override
        public void insertMoney(Denomination type, double amount){
            System.out.println("Dispensing in progress. Cannot insert money now.");
        }
        @Override
        public void selectProduct(String productName){
            System.out.println("Dispensing in progress. Cannot select product now.");
        }
        @Override
        public void dispenseProduct(){
            if(controller.getCurrentSelected() != null && controller.getCurrentSelected().getQuantity() > 0){
                controller.inventory.dispense(controller.getCurrentSelected().getProductName());
                System.out.println("Dispensed: " + controller.getCurrentSelected().getProductName());
                controller.collectMoney();
                controller.setCurrentSelected(null);
            }
            controller.setState(new IdleState(controller));
        }
    }

    class OutOfStockState implements MachineState{
        private VendingMachineController controller;

        OutOfStockState(VendingMachineController c){
            this.controller = c;
        }

        @Override
        public void insertMoney(Denomination type, double amount){
            System.out.println("Product out of stock. Cannot accept money.");
        }
        @Override
        public void selectProduct(String productName){
            System.out.println("Product out of stock.");
        }
        @Override
        public void dispenseProduct(){
            System.out.println("Product out of stock.");
        }
    }

    class InsufficientFundsState implements MachineState{
        private VendingMachineController controller;

        InsufficientFundsState(VendingMachineController c){
            this.controller = c;
        }

        @Override
        public void insertMoney(Denomination type, double amount){
            System.out.println("Insufficient funds. Insert more money.");

        }
        @Override
        public void selectProduct(String productName){
            System.out.println("Insert money first.");
        }
        @Override
        public void dispenseProduct(){
            System.out.println("Cannot dispense. Insufficient funds.");
        }
    }
    ```

### 4. `VendingInventory` (Singleton + Subject)

* Manages stock of products.
* Provides methods to check availability, dispense, and update stock.
* Notifies observers (e.g., `RestockService`) when product stock changes.

    ```java
    interface Subject{
        void addObserver(Observer observer);
        void removeObserver(Observer observer);
        void notifyObservers(String productName, int quantity);
    }

    class VendingInventory implements Subject{

        private static VendingInventory inventoryInstance;
        private final Map<String, Product> productsAvailable;
        private final List<Observer> observers;

        private VendingInventory(){
            this.productsAvailable = new HashMap<>();
            this.observers = new ArrayList<>();
            addProduct("coke", 2);
            addProduct("water", 10);
            observers.add(new RestockService());
        }

        public static synchronized VendingInventory getInstance()
        {
            if(inventoryInstance == null){
                inventoryInstance = new VendingInventory();
            }
            return inventoryInstance;
        }

        public synchronized void addProduct(String productName, int quantity){
            Product product = ProductFactory.createProduct(productName);
            product.setQuantity(quantity);
            productsAvailable.put(productName, product);
            System.out.println("Adding "+ productName + " to inventory.");
            notifyObservers(productName, quantity);
        }

        public synchronized Product getProduct(String productName){
            if(productsAvailable.containsKey(productName)) {
                return productsAvailable.get(productName);
            }
            return null;
        }

        private synchronized void updateProductStock(String productName){
            System.out.println("Updating Stock...");
            getProduct(productName).decrementQuantity();
            System.out.println("Quantity Left: " + getProduct(productName).getQuantity());
        }

        private boolean checkAvailability(String productName){
            int currentQuantity = getProduct(productName).getQuantity();
            if(currentQuantity > 0) {
                System.out.println("Available stock for product " + productName + ": " + currentQuantity);
                return true;
            }
            return false;
        }

        public synchronized void dispense(String productName){
            if(!checkAvailability(productName)){
                throw new IllegalArgumentException("Product not in Stock");
            }
            updateProductStock(productName);
            notifyObservers(productName, getProduct(productName).getQuantity());
        }

        public Map<String, Double> getAllProducts() {
            Map<String, Double> productPriceMap = new HashMap<>();
            for (Map.Entry<String, Product> entry : productsAvailable.entrySet()) {
                productPriceMap.put(entry.getKey(), entry.getValue().getProductPrice());
            }
            return productPriceMap;
        }

        @Override
        public void addObserver(Observer observer){
            observers.add(observer);
        }

        @Override
        public void removeObserver(Observer observer){
            observers.remove(observer);
        }

        @Override
        public void notifyObservers(String productName, int quantity){
            System.out.println("Notifying observer(s)");
            for(Observer ob: observers){
                ob.update(productName,quantity );
            }
        }


    }
    ```

### 5. `Product` & `ProductFactory`

* **Product**: Represents an item (name, price, quantity).
* **ProductFactory**: Creates predefined products (`coke`, `pepsi`, `water`).

    ```java
    class ProductFactory{
        public static Product createProduct(String productName){
            switch(productName.toLowerCase()) {
                case "coke": return new Product("coke", 20.0);
                case "pepsi": return new Product("pepsi", 25.0);
                case "water": return new Product("water", 10.0);
                default: throw new IllegalArgumentException("Invalid product: " + productName);
            }
        }
    };

    class Product {
        private final String productName;
        private final double productPrice;
        private int quantity;

        Product(String name, double price) {
            this.productName = name;
            this.productPrice = price;
        }

        String getProductName(){
            return this.productName;
        }

        double getProductPrice(){
            return this.productPrice;
        }

        int getQuantity(){
            return this.quantity;
        }

        void setQuantity(int quantity){
            this.quantity = this.quantity + quantity;
        }

        void decrementQuantity(){
            if(this.quantity > 0)
            {
                this.quantity = this.quantity-1;
            }
        }
    }
    ```

### 6. `VendingPaymentService` (Payment Handler)

* Handles received money, tracks balance, and calculates change.
* Uses **PaymentStrategy** to handle mode-specific logic (coin/note).

    ```java
    enum Denomination {
        COIN,
        NOTE
    }

    class VendingPaymentService{
        @Setter
        private PaymentStrategy strategy;
        double amountReceived;

        public boolean processPayment(double amount, double productPrice){
            if (amount < productPrice){
                System.out.println("Not enough funds");
                return false;
            }
            strategy.handlePayment(amount, productPrice);
            this.amountReceived = amount;
            return true;
        }

        public double returnChange(double productPrice){
            double change = amountReceived - productPrice;
            amountReceived = 0; // reset after returning change
            return change;
        }

    }
    ```

### 7. `PaymentStrategy` & Implementations (Strategy Pattern)

* **CoinPaymentStrategy** → handles payment in coins.
* **NotePaymentStrategy** → handles payment in notes.

    ```java
    interface PaymentStrategy {
            void handlePayment(double receivedAmount, double deductionAmount);
        }

        class NotePaymentStrategy implements PaymentStrategy{
            @Override
            public void handlePayment(double receivedAmount, double deductionAmount){
                System.out.println("Handling note payment. Deducting: " + deductionAmount);
            }
        }

        class CoinPaymentStrategy implements PaymentStrategy{
            @Override
            public void handlePayment(double receivedAmount, double deductionAmount){
                System.out.println("Handling coin payment. Deducting: " + deductionAmount);
            }
        }
    ```

### 8. `Observer` Pattern (Restock Service)

* `RestockService` observes inventory stock changes.
* Prints a notification and alerts if restock is needed.

    ```java
    package vendingMachine;

    public interface Observer {
        void update(String productName, int quantity);
    }

    public class RestockService implements Observer {
        @Override
        public void update(String productName, int quantity) {
            System.out.println("[RestockService] Product: " + productName + " new quantity: " + quantity);

            if(quantity == 0){
                System.out.println("[RestockService] Restock for " + productName + " needed!! ");
            }
        }
    }

    ```


<hr />

## Flow (High-Level)

1. **User selects product** → `IdleState` validates availability.
2. Machine enters `WaitingForMoneyState`.
3. **User inserts money** → payment processed via `VendingPaymentService` and appropriate strategy.
4. If enough → moves to `DispensingProductState` → product dispensed + change returned → state resets to `IdleState`.
5. If insufficient → `InsufficientFundsState` prompts for more money.
6. If product is out of stock → `OutOfStockState`.

<hr />

## Changes to ensure thread safety and Concurrency
### 1. VendingMachineController

- Original: VendingMachineController.currentSelection was a single shared field.

- Change: Made it ThreadLocal<Product>, so each user/thread can select a product independently without collisions.

- `private ThreadLocal<Product> currentSelection;`

### 2. Per-thread payment tracking

- Original: VendingPaymentService.amountReceived was shared across threads → race conditions.

- Change: Made amountReceived ThreadLocal or used ThreadLocal PaymentService per thread.

- Ensures each transaction maintains its own payment state.

- `private ThreadLocal<Double> amountReceived = ThreadLocal.withInitial(() -> 0.0);`

### 3. Synchronized inventory operations

- Original: Inventory methods could be accessed concurrently → stock updates could collide.

- Change: Added synchronized to critical inventory methods:

  - addProduct()
  - getProduct()
  - dispense()
  - updateProductStock()

- `public synchronized void dispense(String productName) { ... }`

- Ensures that stock decrement, availability check, and notification happen atomically.

<hr />

## Resources

- [Code Repository](https://github.com/divyadhimaan/lld-playground/tree/main/code/src/vendingMachine)
